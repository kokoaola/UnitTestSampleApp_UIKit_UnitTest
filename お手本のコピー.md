# UnitTest

## UnitTestとは
- 単体テストのこと
- コードの一部をテストするために作成する非常に小さな自己完結型のメソッド
- 単体テストのコードはシンプルで小さい
- 単体テストは特定の引数を使用して関数を呼び出し、テスト対象から帰ってきた結果を検証する
- 1つのテストでは、必ずん1つの機能を検証する。複数の機能を1つの単体テストで検証するのはNG
- 作成するには、XCTest Frameworkを使うのが良い。テストにクリアすると緑のチェックボックス✅が、クリアしないと赤いバツマーク❌が出る
- 単体テストはダミーのオブジェクトを使用し依存関係がないため高速で実行される
- 単体テストはネットワークに接続やデータベース操作を実行しない（これらを実行するテストは統合テスト）


## Testの種類
- 「Unit Tests（単体テスト） - Integration Tests（統合テスト） - UI Tests」の順で行われる
### Unit Tests
- すべてのテストの前に実行される。ダミーのオブジェクトを使用することで、依存関係を持たせないテスト
- ネットワークに接続やデータベース操作を実行しないため高速で実行される
- 頻繁に実行される
### Integration Tests
  - ダミーのオブジェクトが使用されず、依存関係が生じた状態で行うテスト（HTTPリクエストを送信したり、データベース操作する）
  - 外部システムと通信する必要があるため、単体テストよりも実行が遅くなる
### UItests
  - UIがちゃんと表示されるかのテスト 
  - デバイス上でアプリを実行し、ユーザーの動作をシミュレートして、アプリが期待通りに動作するかどうかをテストする



## ユニットテストのF.I.R.S.T.の原則
F.I.R.S.T.の原則を守ることで、ユニットテストの品質と効果性を高め、開発プロセス全体をスムーズに進めることができる
- F(Fast)
  - 早く動く必要がある。
  - ネットワークに接続やデータベース操作を実行しない
- I(Independent)
  - 互いに独立している、依存関係がない
  -  一つのテストが失敗しても、他のテストには影響を与えないようにすることで、問題の特定が容易になる。
- R(Repeatable)
  - 反復可能でなければならない
  - 複数回実行しても、別の環境で実行しても、同じ結果が得られる。
- S(Self-validating)
  - 自己検証。単体テストが成功したか失敗したかを知るために、開発者は何もすべきではない。
  - 単体テストは、テスト対象の関数の結果を検証し、それ自体が合格か不合格かを決定する。
  - 人間が結果をチェックする必要がないので、テストの結果の解釈が一貫する。
- T(Thorough & Timely)
  - 徹底したテスト駆動開発
  - アプリの機能の開発中に単体テストを作成する
  - コードを実稼働環境にプロモートする前に、コードを単体テストでカバーする



## テスト駆動開発
- 非テスト駆動開発は、コードを書いた後にテストを作る
- テスト駆動開発は、コードを書く前にテストを先に書く
### テスト駆動開発のライフサイクル(Red->Green->Refactor->Repeat)
- Red:失敗するテストの作成
  - 最初に新しい機能や修正をテストするためのテストケースを書く。この時点では、実際の機能や修正は実装されていないため、テストは失敗する。
- Green:テストを通過する最小限のコードの実装
  - テストケースが通過するための最小限のコードを作成する。完璧な実装よりもテストを成功させることが重要。
- Refactor:リファクタリング
  - 単体テストのコードとアプリのコードをクリーンアップして、見た目も動作も良くする。このテストが通ることを確認しながら、コードの改善をおこなうこと。再利用および改善できるコードがあるかどうかを確認
- Repeat: 前の 3 つの機能を繰り返して実装する



## Xcodeのプロジェクトへの導入方法
### プロジェクト作成時に追加
- Appプロジェクト作成時、下の方にある「Include Tests」のチェックボックスにチェックを入れる
- ソースツリー一番上のプロジェクト名をクリックすると、ターゲットにxxxxTestsとxxxxUITestsが自動で追加される。ソースツリーにもxxxxTestsとxxxxUITestsフォルダが追加される
- フォルダの中にはSwiftファイルがあって、デフォルトのテンプレートのテストケースが作成されている
### あとから追加
- あとからUnitTestを追加したい場合は、ソースツリー一番上のプロジェクト名をクリック、Targetの下の＋ボタンからUnitTestを検索して導入する



## テストで使用するメソッドについて
- テストを導入すると、xxxxTestsフォルダが自動で追加され、フォルダの中にはxxxxTests.swiftというファイルが生成される。このファイルにはテンプレート用のテストケースクラスが自動で記述してある

### setUpメソッド
- 各単体テストのインスタンスの作成など、テストケースに共通する初期設定や前処理を行うために使用されるメソッド
- テストメソッドの前に呼び出される
  #### class func setUp():
  - クラスメソッドのため、各クラスのライフサイクルにおいて、最初に1回だけ実行される
  - 各ユニットテストで共通して使用するインスタンスを作成したりする
  #### func setUp():
  - インスタンスレベルのメソッドのため、テストケースクラス内の各テストメソッドが呼び出される前に、毎回1回呼び出される
  #### func setUpWithError():
  - テンプレートに自動で追加されるメソッド
  - エラーを投げることができる。それ以外はfunc setUp()と同じ

### tearDownメソッド
- テストメソッドの処理が終了したあとに呼び出される、クリーンアップ用のメソッド
- メモリの負荷の解消するため、setUpWithErrorで行った初期設定やテストメソッドが作成したリソースを解放する処理を記述することが多い
  #### class func tearDown():
  - クラスメソッドのため、各クラスのライフサイクルの最後に1回だけ実行される
  #### func tearDown():
  - インスタンスソッドのため、テストケースクラス内の各テストメソッドが終わるごとに毎回呼び出される
  #### tearDownWithError():
  - テンプレートに自動で追加されるメソッド
  - エラーを投げることができる。それ以外はfunc tearDown()と同じ

### testメソッド
  - コードの隣にひし形◇マークがあるメソッド
  - 実際に行う内容を記述するテストメソッド（テストが成功するとひし形が緑になって、失敗すると赤くなる）d\
  - XCTAssertを使用して、テストが期待通りの結果を返すかを確認できる
  ### testExample():
  - テンプレートに自動で追加されるメソッド
  - テストしたい内容を記述する
  - メソッド名をtestから始まるメソッドを作ることで、テストメソッドは好きなだけ作成できる（名前が重複してはだめ）
  - テストメソッドが複数ある場合、実行される順番はアルファベット順になる（並び順は関係なし）
  - テストメソッドを複数作るときは、それぞれが独立した内容であること（テストメソッド1の結果を使用して、テストメソッド2を行う、とかは独立性がないためダメ）
  

  ### testPerformanceExample():
   - パフォーマンステスト用のメソッド
   - コードの実行時間を計測して、パフォーマンスのベンチマークや改善点を確認できる
   - 必要ない場合は何も書かなくてもOK

### addTeardownBlock:
- テストメソッド内に記述するブロック
- addTeardownBlockに追加されたブロックは、tearDownWithError()の後、tearDown()の前に実行される
- tearDownメソッドのような、クリーンアップに関する処理を記述し、tearDownメソッドの代わりや補完として使用することが多い

### クラスレベルの各メソッドが呼び出される順番まとめ
class func setUp()  
[1サイクル目] setUp()またはsetUpWithError() -> 1つめのtestMethod -> addTeardownBlock -> tearDownWithError()またはtearDown()  
[2サイクル目] setUp()またはsetUpWithError() -> 2つめのtestMethod -> addTeardownBlock -> tearDownWithError()またはtearDown()  
[3サイクル目]  ...  
class func tearDown()
- **setUpWithError()とsetUp()が両方存在している場合は、setUpWithError()が先に実行され、tearDownWithError()とtearDown()が両方存在している場合は、tearDown()が先に実行される**


## 新しいテストケースクラスを追加で作成する
- com + n で新規作成 -> UnitTestCaseClassを検索して選択する -> テストクラス名(xxxxTests)を入れて、XCTestCaseのサブクラスになっているか確認しNext -> 新しいテストケースクラスを作成したいフォルダを選択する(すでに存在するUnitテスト用のフォルダを選択する) -> Targetsはひし形4つのアイコンのUnitTestsのみにチェック -> Create -> 新しくテストケースクラス用のファイルが作成されるので、最初に作成されたswiftファイルのコード上部の「@testable import プロジェクト名」をコピーして、新しいファイルのimport行の下にペーストする

### @testable importとは？
- テストコード用の特殊なコード
- テストターゲットからプログラム（モジュール）にアクセスできるようになり、変数などをテストコードで利用できる




### 動かしてみる
- ひし形が緑になったらテスト合格、赤くなったら不合格
- テスト合格の場合はprint文は表示されず、不合格の場合は表示される
#### ソースコードから実行
- ファイルのコードの右側のひし形をクリックする
- テストケースクラスの右側のひし形をクリックすると、クラス内のすべてのテストメソッドが実行される
- テストメソッドを選んで実行したいときは、メソッドの隣のひし形をクリック
```Swift
import XCTest
@testable import UnitTesting

final class UnitTestingTests: XCTestCase {
    

    override class func setUp(){
        print("クラスメソッドのsetUp()が呼び出された")
    }
    
    override func setUp(){
        print("インスタンスメソッドのsetUp()が呼び出された")
    }

    
    override func setUpWithError() throws {
        print("インスタンスメソッドのsetUpWithError()が呼び出された")
    }

    
    override class func tearDown(){
        print("クラスメソッドのtearDown()が呼び出された")
    }
    
    override func tearDown(){
        print("インスタンスメソッドのtearDown()が呼び出された")
    }

    override func tearDownWithError() throws {
        print("インスタンスメソッドのtearDownWithError()が呼び出された")
    }


    func testExample() throws {
        print("テストメソッドのtestExample()が呼び出された")
        addTeardownBlock {
            print("addTeardownBlockが呼び出された。このブロックは、tearDownWithError()メソッドの前に呼び出されます。")
        }
    }

    

    func testPerformanceExample() throws {
        // This is an example of a performance test case.
        self.measure {
            // Put the code you want to measure the time of here.
        }
    }
}

```
#### Test Navigatorから実行
- ソースツリー上部の横に並んだアイコンから、ひし形マークを選択。階層からテストを実行できる
#### ショートカットで実行
- com + uでテストケースクラスのすべてのテストメソッドを実行
#### 一部のテストを無効にしたい時
- ソースコードのひし形を右クリックし、Disable テスト名をクリックする。欠点：有効になっているのか無効になっているのかぱっと見わからない
- Test Navigatorのひし形を右クリックし、Disable テスト名をクリックする。無効になったメソッドは薄いグレーになる
- スキーマ - Test - 無効にしたいメソッドのチェックを外すことで無効にできる
- [func testxxxx]を[test_xxxx]みたいにアンダースコアで分けることでXcodeに認識されなくなり、無効にできる
#### 詳しい結果を見たい時
ソースツリー上部の横に並んだアイコンから、レポートマークをクリック。テストの結果を日付ごとに確認できる。logからレポートメッセージが確認できる。失敗の記録の右の、横線が重なったアイコンをクリックするとコンソールの履歴も見れる


### テストメソッドを作る時の約束
- testから始まるメソッド名にすること（そうしないとXcodeにテストメソッドだと認識されない）
- 引数を受け取らないこと
- 戻り値を返さないこと
#### 名付けについて
iOS開発では、一般的に下記のパターンとなることが多い
- test[関数名やクラス名など、テストの対象となるシステムの名前]\_[何が起きたら]\_[どのような結果を期待しているか等合格の条件]